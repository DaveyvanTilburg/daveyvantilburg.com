<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=windows-1252"/>
	<title></title>
	<meta name="generator" content="LibreOffice 6.2.5.2 (Windows)"/>
	<meta name="created" content="2020-10-04T10:48:56.905000000"/>
	<meta name="changed" content="2020-10-04T20:44:45.032000000"/>
	<style type="text/css">
		@page { size: 8.27in 11.69in; margin: 0.79in }
		p { margin-bottom: 0.1in; line-height: 115%; background: transparent }
		h3 { margin-top: 0.1in; margin-bottom: 0.08in; background: transparent; page-break-after: avoid }
		h3.western { font-family: "Liberation Sans", sans-serif; font-size: 14pt; font-weight: bold }
		h3.cjk { font-family: "Microsoft YaHei"; font-size: 14pt; font-weight: bold }
		h3.ctl { font-family: "Arial"; font-size: 14pt; font-weight: bold }
		a:link { color: #000080; so-language: zxx; text-decoration: underline }
	</style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr"><p align="center" style="margin-top: 0.17in; margin-bottom: 0.08in; line-height: 100%; page-break-after: avoid">
<font face="Liberation Sans, sans-serif"><font size="6" style="font-size: 28pt"><b>What
is OOP?</b></font></font></p>
<p align="left" style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">History</h3>
<p>I wish to write something on my experiences with OOP and my
current standing on it. I hope to inspire new insights and new
perspectives on what OOP is, and how to work with it.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>I&rsquo;ve decided only to include the paradigm and programming
evolution's I&rsquo;ve found relative to OOP in the next part where I
wish to work through the history of programming languages, before
arriving at OOP.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Low level</h3>
<p>For example: Machine Code. This language exists direct
instructions on the CPU.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">High level</h3>
<p>This is a &lsquo;simplified&rsquo; language that is further away
from the CPU, and closer to something the software developer can
understand (at least, that is the goal).</p>
<p>There have been multiple iterations between translated at run-time
vs compiled at build time. As well as languages very specific for a
purpose to general purpose languages.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Structured programming (control flow)</h3>
<p>After the first high level programming languages were
created,&lsquo;control flow&rsquo; was introduced, in contrast to
previous languages where control flowed from top to bottom (or
jumping). It was now possible to jump between grouped pieces of code
and share state (data) between them. Bringing organization.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>In these languages it is the software developer who chooses what
the control flow will be, given a certain state.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>These languages introduced:</p>
<p>- Blocks: the grouping of statements to be handled as if a single
statement.</p>
<p>- Subroutines: also known is procedures/functions/methods. A
reference to a code block and what is required to call it, and what
it will return.</p>
<p>- Sequencing: being able to order statements and subroutine calls
to be executed in a sequence.</p>
<p>- Flow control: if/then/else</p>
<p>- Iteration: while/do/for</p>
<p>- Recursion: A statement that is able to call itself</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Procedural Programming Paradigm</h3>
<p>Is a design philosophy, oriented around the fact that data is what
changes at run-time. Where structured programming was an evolution in
the language, Procedural programming was an evolution in thought (or
design) and helps us structure all these new procedures introduced by
the language capabilities.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Declarative vs imperative</h3>
<p>Imperative programming is programming where the programmer
describes the control flow and the data is the first-class citizen.
Meaning that the data is highly volatile at run-time while the
program&rsquo;s control flow composition is created at compile time.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>Declarative programming differs from imperative in that it leaves
the control flow to the run-time, and only describes &lsquo;the what
it tries to achieve&rsquo;. This for me is somewhat hard to visualize
so I&rsquo;ve decided to elaborate a bit more about what this means,
as I see it very important to understand later on for OOP.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>In DataFlow Programming you define the &lsquo;steps&rsquo; without
defining the &lsquo;order of steps&rsquo;. Once a step&rsquo;s
expected input (data) is valid the run-time will give control to the
step to run on the data.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>In Functional Programming the functions are the first-class
citizens instead of the data. This means that the composition of the
program is not set at compile time (If my reading of this is correct,
sadly I don&rsquo;t have extensive first hand experience with
functional programming. Though I like the philosophy of declarative
design).</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Difference</h3>
<p>Declarative programming languages are inherently side effect free
and thus less prone to bugs. This is because when running multi
threaded the state is never shared between threads, or even in a
single thread if a complex series of procedures run on the same
shared state. State, or data, is a second-class citizen in these
language's and so only exist within the confines of the first-class
citizen: the &lsquo;declaration&rsquo;, be it a step, function or
what ever the declarative languages chooses to declare.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>Imperative programming has data as its first-class citizen and so
can share state between procedures. Making it prone to side effects
and bugs, thus putting a higher load on the software developer to
&lsquo;make the right choose&rsquo;. Be it through discipline or
design choose.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Object oriented programming</h3>
<p>Then comes object oriented programming. I&rsquo;ve chosen to
separate the language evolution and the paradigm evolution into their
own respective topics. First, programming:</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>Since OOP is an evolution of procedural programming, most
languages are multi-paradigm. For example, C# has chosen to keep all
procedural capabilities of its former language and added the new
capabilities introduced by OOP. 
</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>These being:</p>
<p>- <b>Dynamic polymorphism</b>: Method overriding (within same
class or inheritance)</p>
<p>- <b>Static polymorphism</b>: Method overloading (multiple methods
with the same name, but different arguments)</p>
<p>- <b>Inheritance</b>: being able to extend on existing classes by
referring to them in a class&rsquo;s definition. Inheriting all the
referenced class&rsquo;s structure and logic and being able to modify
or extend upon it.</p>
<p>- <b>Abstraction</b>: being able to describe a class in less
detail (interfaces / base classes).</p>
<p>- <b>Encapsulation</b>: Classes are blueprints of objects, objects
being an instanced class living in memory. Being able to construct it
with data, which lives enclosed inside the object.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Object oriented programming paradigm</h3>
<p>Now that we know the new features OOP brings to languages, we can
also see why it might be difficult to know what pure OOP is if you
only look at the languages that claim to be OOP, since multiple
paradigm&rsquo;s can be supported by a single language. C# for
example also incorporates possibilities to write programs using the
functional paradigm. Making it even harder to design software if you
are simply &lsquo;using&rsquo; a language. Rather than designing
software according to some design philosophy.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>The OOP paradigm summed very short: bringing together data and
methods that operate on that data. Where the instance (object)
represents something tangible.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>Seems easy, but I&rsquo;ve read lots of books to get a good and
thorough understand of what OOP is and it has till only recently been
quite puzzling to not be confused about all those rules and
disciplines. If you know OOP, you probably heard of SOLID. Which are
5 principles that help you build OOP software. But using the rules
and not seeing code through the correct paradigm makes it very
confusing. For instance, what is the Single responsibility of the
object in SRP?</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>I kept asking myself &lsquo;why do these rules matter&rsquo; and
&lsquo;why am I doing it this way?&rsquo;. So I&rsquo;ve delved some
more into OOP, not just through what it does to the software
language, but what the paradigm tries to solve.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Computer costs vs Man hour costs</h3>
<p>Back in the good ol day, computer processing power costs were much
higher than man hour costs. So, in order to get software running it
had to be super efficient with it resources. This means the code was
written for the computer to read, not for the developer to read.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>Through the course of time and hardware evolution, hardware
resources are not scarce anymore and are very cheap comparatively.
This means that the hardware is no longer expensive, you are. You,
the software developer.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Procedural vs OOP as a paradigm</h3>
<p>My conclusion is that, OOP compared to Procedural tries to improve
code maintainability. So that YOU, the software developer, become
cheaper, by being more efficient. Achieving this by improving
readability (faster and more accurate interpretation of the code).
Through improving the readability: improving the maintainability
(smaller chance to introduce bugs, implement features faster and when
performance is an issue, it can be solved quickly)</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>From what I see, even though the new advantages we get with these
new features in the language evolution, the paradigm evolution is not
that clear to me. If OOP tries to solve such complexity in the code,
why isn&rsquo;t it, for example, inherently declarative styled?</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>I think it comes down to this, many languages evolve by the use
and need of the developers. If the developers often have reflection
needs, the language will developer reflection capabilities. If
generics are a must, then it will be added. Even if, some of us are
against such additions. Meaning that languages will &lsquo;go with
the flow&rsquo; of the greater demand. This does not mean we always
have to use it, it is great that C# has all these different paradigms
incorporated into it so that we can always use the features we need
in the given moment. But we should not abuse it. (much like F# which
is functional, but also includes OOP capabilities to handle objects)</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Concepts</h3>
<p>Now what I see is the biggest advantage in the OOP paradigm vs the
Procedural paradigm. Is what you can do with it if you look at your
code through the right lens. Think of concepts. If you have a list of
products and a person, and have a bit of code that uses it together.
There is hidden meaning there. The both of them together might bring
the concept of an &lsquo;Order&rsquo;, or maybe together they mean a
&lsquo;Supplier&rsquo;. It would be great if this was easy to read
instead of having to go through to code to find its meaning. So, our
first object surfaces in OOP. In procedural, these concepts would be
spread out over multiple methods throughout our codebase. Or maybe in
one very long method.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>That, is what I think it the true power of OOP. Due to revealing
these hidden concepts, we have something to orient and group our code
around. Giving them meaning. Which helps us understand and maintain
our code, and gives our projects some life. The files and namespaces
start to become words of the problem domain instead of ambiguous
titles like &lsquo;MathHelper&rsquo;.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Groupthink, versus thinking</h3>
<p>Now what I do not like when I have discussions about OOP, is that
I&rsquo;ve experienced allot of &lsquo;groupthink&rsquo;. Groupthink
to me means, what ever I&rsquo;ve read, or what ever I&rsquo;ve heard
someone with credit say, is what I think, and I will use that as an
argument to do things &lsquo;this way&rsquo;.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>I don&rsquo;t like that. I prefer to have discussions that orient
around the match between language, paradigm, framework,
infrastructure&hellip; so on, and the project being realized.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>I really get that SOLID are great principles, but clinging to them
while you are realizing a prototype  is counter productive. Using
Ruby because you have experience with it is no argument to start
every new project with Ruby. 
</p>
<p><br/>
<br/>

</p>
<h3 class="western">Architecture</h3>
<p>When you think about a software&rsquo;s architecture. You are
thinking about the design associated to the quality attributes of the
project. The quality attributes being requirements like: &lsquo;It
needs to have 100 fail recovery&rsquo;, &lsquo;It must have 99.99% up
time&rsquo;, &lsquo;has to be cheap to host and develop&rsquo;, &lsquo;must
be platform independent&rsquo; or &lsquo;we need full insight in what
happens to requests that go through the system&rsquo;.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>These quality attributes help decide not only what frameworks you
should use, but also which languages match best for the task at hand.
Maybe it even divides the software into multiple components with
different languages that best match it&rsquo;s primary concern. These
are the types of arguments you should have.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Conclusion</h3>
<p>I don&rsquo;t really care what language I develop in, or what
paradigm I use. What I like about software development are the smart
solutions. Thoroughly thought through solutions that best match the
well researched task at hand. OOP is not always the solution. Its the
combination of how you use it, your design skills, the team you work
in, the project at hand, and your practice that make the difference.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<h3 class="western">Final thoughts</h3>
<p>I love OOP, but I do not like its ambiguity together with the
enforcement of rules. I would much rather work in a group of people
that love their profession and delve deep into what they can do with
a language. That way, everyone brings something to the table and help
each other grow rather than restrict our creativity by introducing
rules. 
</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>I&rsquo;ve had so many situations where letting SRP go for a bit
makes the world of difference. And many more where it make sense. I
believe that OOP is so broad, that it is a great platform to build
wonderful things with, as long as you understand the situation you
are in.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>I really want to stipulate that last line again. Understand the
situation you are in. There usually is nothing constraining your
creativity even though you might feel pressure, and there is always
time to ask more questions about the project, and what the customer
expects. Running on assumptions means you impact your creativity.
Asking for extra time, asking for more clarity or proposing a
different solution that you think better fits the situation, opens up
worlds of possibilities that no rule or constraint should constrain.</p>
<p style="margin-bottom: 0in; line-height: 100%"><br/>

</p>
<p>Only then, can you truly appreciate what OOP brings to the table.
Because OOP code requires more thought (and thus time) to write, but
requires less cognitive load to understand and maintain later. That
is the trade off, because for every line of code you write, you (and
your colleagues) will read it 10 times.</p>
<p style="page-break-before: always">Sources:</p>
<p><a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a></p>
<p><a href="https://en.wikipedia.org/wiki/Structured_programming">https://en.wikipedia.org/wiki/Structured_programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/Procedural_programming">https://en.wikipedia.org/wiki/Procedural_programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/Imperative_programming">https://en.wikipedia.org/wiki/Imperative_programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/Declarative_programming">https://en.wikipedia.org/wiki/Declarative_programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/Dataflow_programming">https://en.wikipedia.org/wiki/Dataflow_programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/Functional_programming">https://en.wikipedia.org/wiki/Functional_programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/SOLID">https://en.wikipedia.org/wiki/SOLID</a></p>
<p><a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design">https://en.wikipedia.org/wiki/GRASP_(object-oriented_design</a>)</p>
<p><br/>
<br/>

</p>
<p>And of course the books I&rsquo;ve read which can be found in a
different section on my website.</p>
<p><br/>
<br/>

</p>
</body>
</html>